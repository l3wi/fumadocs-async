import { mkdir, writeFile } from 'node:fs/promises'
import path from 'node:path'
import { stringify as stringifyYaml } from 'yaml'
import type {
  AsyncConfig,
  AsyncSchemaToPagesOptions,
  OutputFile,
  ProcessedAsyncDocument,
} from '../types'
import {
  buildPageEntries,
  reserveEntryPath,
  type AsyncPageEntry,
} from './utils/page-context'

interface GeneratedEntry {
  filePath: string
  content: string
}

const DEFAULT_COMPONENT = 'AsyncAPIPage'

export async function generateAsyncFiles(options: AsyncConfig): Promise<void> {
  if (!options.input) {
    throw new Error('generateAsyncFiles: input server is required.')
  }

  if (!options.output) {
    throw new Error('generateAsyncFiles: output directory is required.')
  }

  const schemas = await options.input.getSchemas()
  const outputDir = resolveOutput(options.output)

  for (const [key, document] of Object.entries(schemas)) {
    const entries = buildEntriesForDocument(key, document, options, outputDir)
    const files: OutputFile[] = entries.map((entry) => ({
      path: entry.filePath,
      content: entry.content,
    }))

    if (options.beforeWrite) {
      await options.beforeWrite(
        {
          document,
          operations: document.operations,
        },
        files
      )
    }

    for (const file of files) {
      await mkdir(path.dirname(file.path), { recursive: true })
      await writeFile(file.path, file.content, 'utf8')
    }
  }
}

function buildEntriesForDocument(
  documentKey: string,
  document: ProcessedAsyncDocument,
  options: AsyncConfig,
  outputDir: string
): GeneratedEntry[] {
  const entries: GeneratedEntry[] = []
  const pageEntries = buildPageEntries(documentKey, document, options)
  const usedPaths = new Set<string>()

  for (const ctx of pageEntries) {
    const relativePath = reserveEntryPath(ctx, usedPaths, { extension: '.mdx' })
    const absolutePath = path.join(outputDir, relativePath)
    const content = createPageContent(ctx, options)
    entries.push({ filePath: absolutePath, content })
  }

  return entries
}

function createPageContent(
  entry: AsyncPageEntry,
  options: AsyncSchemaToPagesOptions
): string {
  const componentName = options.component ?? DEFAULT_COMPONENT
  const imports = normalizeImports(options.imports)
  const includeComment = options.addGeneratedComment ?? true
  const comment = includeComment
    ? [
        '/**',
        ' * This file was generated by fumadocs-asyncapi.',
        ' * Do not edit manually unless you know what you are doing.',
        ' */',
        '',
      ].join('\n')
    : ''

  const frontmatter = serializeFrontmatter(entry.frontmatter)
  const props = buildComponentProps(entry)

  return [
    comment,
    frontmatter,
    imports,
    '',
    `export default function Page() {`,
    `  return (`,
    `    <${componentName}`,
    ...props.map((prop) => `      ${prop}`),
    `    />`,
    `  )`,
    `}`,
    '',
  ]
    .filter(Boolean)
    .join('\n')
}

function resolveOutput(output: string): string {
  return path.isAbsolute(output) ? output : path.resolve(process.cwd(), output)
}

function serializeFrontmatter(data: Record<string, unknown>): string {
  const yaml = stringifyYaml(data, { aliasDuplicateObjects: false }).trimEnd()
  return ['---', yaml, '---', ''].join('\n')
}

function normalizeImports(imports?: string | string[]): string {
  if (!imports) {
    return `import { ${DEFAULT_COMPONENT} } from 'fumadocs-asyncapi/ui'\n`
  }

  const block = Array.isArray(imports) ? imports.join('\n') : imports
  return block.endsWith('\n') ? block : `${block}\n`
}

function buildComponentProps(entry: AsyncPageEntry): string[] {
  const props: string[] = [`document="${escapeAttribute(entry.documentKey)}"`]

  if (entry.channel?.name) {
    props.push(`channel="${escapeAttribute(entry.channel.name)}"`)
  }

  if (entry.operation?.direction) {
    props.push(`direction="${entry.operation.direction}"`)
  }

  if (entry.operation?.operationId || entry.operation?.id) {
    props.push(
      `operationId="${escapeAttribute(
        entry.operation.operationId ?? entry.operation.id ?? ''
      )}"`
    )
  }

  if (entry.tags?.length) {
    props.push(`tags=${formatArrayAttribute(entry.tags)}`)
  }

  return props
}

function escapeAttribute(value: string): string {
  return value.replace(/\\/g, '\\\\').replace(/"/g, '\\"')
}

function formatArrayAttribute(values: string[]): string {
  const serialized = values.map((value) => `"${escapeAttribute(value)}"`).join(', ')
  return `{[${serialized}]}`
}
